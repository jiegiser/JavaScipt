<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>第三章</title>
    <style>
        body {
            /* 文字居中 */
            text-align: center;
        }

        img {
            /* 圆角 */
            border-radius: 50%;
            /* 过渡效果 */
            transition: all 0.5s;
            -webkit-transition: all 0.5s;
            -o-transition: all 0.5s;
            cursor: pointer;
        }

        img:hover {
            /*scale就是缩放，当鼠标进行图片的时候，图片缩放到1.1倍  */
            transform: scale(1.1);
        }
    </style>
</head>

<body>
    <div>
        <strong>要点1</strong>
        <hr>
        <div>
            <p>javascript变量名是区分大小写，他的标识符按照规范为驼峰式命名，也就是第一个字母小写，下一个单词首字母大写。</p>
            <br>
            <p>对于未声明的变量调用delete不会导致错误，但是在严格模式下，会出现错误，对于初始化的变量执行typeof操作符会返回
                undefined，而对于未声明的变量执行typeof操作符同样也会返回undefined值、
            </p>
            <br>
            <p>boolean中的true与false是区分大小写的，要将任何一个值转换为bool类型，使用Boolean转换函数</p>
        </div>
        <script>
            // 这样使用一条语句可以定义多个变量
            // var message = 'hi',
            //     found = false,
            //     age = 29;
            // function test(){
            //     var re='hi';
            // }
            // alert(re);//报错re is not defined
            // ecmascript有七种数据类型undefined、null、Boolean、Number、String、Symbol、Set



            // var say;
            // console.log(say);//undefined
            // console.log(arr);//会报错  arr is not defined


            // console.log(typeof say);//undefined
            // console.log(typeof arr);//undefined
            // 
            // var ObNnull=null;
            // console.log(typeof ObNnull);//object表示空对象
            // 
            // console.log(null==undefined);//true
            // 
            // console.log(ObNnull);//null,判断是否为null，只需要==null，就可以


            // console.log(Boolean("ddddd"));//Boolean转换为boolean类型
            // console.log(Boolean(''));//false
            // console.log(Boolean(null));//false
            // console.log(Boolean(NaN));//false
            // console.log(Boolean(0));//false
            // console.log(Boolean(undefined));//false


            // 2019-1-17
            // 任何数据类型的值调用Bollean函数，都会返回一个Boolean值，这里需要注意的是，数值中，0跟NaN返回的为false
            // Number类型
            // 注意八进制的其前面第一个为0，然后后面是0到7，如果前面是0，后面的数值超过了7，那就是十进制了；
            // 十六进制的前两位必须是0x，
            // let hex=0xA;
            // console.log(hex);//10
            // // 在进行算数计算的时候，所有八进制以及十六进制的都会转换为十进制的数值。
            // let hex1=+0;
            // let hex2=-0;
            // console.log(hex1);
            // console.log(hex2);
            // console.log(hex1==hex2)//true
            // console.log(hex1===hex2)//true

            // ------科学计数法
            // let floatname=3.12e7;
            // console.log(floatname);//31200000也就是3.12乘以10的7次方
            // 浮点数值的最高精度为17位小数，但在进行算数计算的时候，他的精度远远不如整数，比如下面的：
            // let float1=0.1;
            // let float2=0.2;
            // console.log(float1+float2);//0.30000000000000004


            // ----数值范围--
            // 最小的数
            // const min=Number.MIN_VALUE;
            // console.log(min);
            // 最大的数---如果一个数组超过了这个最大的数值，该数组将自定转换为特殊的Infinity
            // const max=Number.MAX_VALUE;
            // console.log(max);
            // 判断数组是否合法，也就是说判断数值是否在最小到最大之间，使用isFinite()函数,如果合理返回true
            // const result=Number.MAX_VALUE+Number.MAX_VALUE;
            // console.log(isFinite(result));//false

            // -----NaN------
            // 在Javascript中，任何数组除以非数字会返回NaN，而在其他语句中就会报错。
            // 这里需要注意的是：任何涉及NaN的操作都会返回NaN，以及NaN与任何值都不相等，报错他本身。
            // console.log(NaN==NaN)//false
            // 有一个isNaN()函数，他可以接受任何一个值，当他接受一个值后，他会尝试将这个值转换为数值，，某些不是数值的值会直接
            // 转换为数值，如果不能转换那么该函数返回true。
            // console.log(isNaN(NaN))//true
            // console.log(isNaN("sdksjdksd000"));//true
            // 这里需要注意的是，isNaN适用于对象，在基于对象调用isNaN函数时，会首先调用对象的valueOf方法，然后确定该方法返回的值
            // 是否可以转换为数值，如果不能，则基于这个返回值再调用toString方法，再测试返回值。

            // -----数值转换-----
            // 有是三个函数可以将非数值换换为数值，Number()、parseInt(),parseFloat;
            // 第一个函数可以用于任何数值类型。另外两个则专门用于将字符串转换为数值。
            // 这里需要注意的是Number函数中,如果是undefined的,返回为NaN.如果为字符串:如果字符串只包含数字(包括正负号),会转换
            // 数字,注意前导的0会被忽略,如果字符串包含有效的浮点格式,比如1.1,那么会将其转换为对应的浮点数值,同样,前导0会被忽略.
            // 如果字符串包含有效的十六进制格式,会将其转换为相同大小的十进制数.
            // 如果字符串是空的,会将其转换为0,如果字符串包含除了上述格式之外的其他字符,将会转化为NaN;
            // 如果转换的是一个对象,那么他首先会调用对象的ValueOf方法,然后暗转跟起那么的规则依次进行转换,如果转换的结果为NaN,那么
            // 会调用对象的toString方法，然后按照前面的规则进行转换字符串。
            // console.log(Number('Hello World'));//NaN
            // console.log(Number('00000444'));//444
            // console.log(Number(true));//1
            // console.log(Number('454545Hello'));//NaN

            // 由于Number方法处理的规则复杂且不够合理，因此在处理整数的时候更常用的是parseInt函数。
            // parserInt会忽略字符串前面的空格。如果第一个字符不是数字字符或者负号，parseInt就会返回NaN。也就是说用它转换空字符串
            // 会返回NaN(Number函数会返回0),如果第一个字符是数字字符，那么他会继续解析第二个字符，知道解析完所有后续字符绘制遇到了
            // 一个非数字字符。例如1234blue会转换为1234，blue会被忽略，类似22.5会转换为22，因为小数点并不是有效的数字字符。
            // 如果字符串中的第一个字符是数字字符，parseInt也能够识别出各种整数格式，（及前面所讨论的八进制和十六进制），也就是说
            // 如果字符串以0x开头且后跟数字字符。就会将其当为一个十六进制的整数，如果字符串以0开头且后跟数字字符，则会将其当做一个
            // 八进制的数值进行解析。
            // console.log(parseInt('123dsfsdfsdf'));//123
            // console.log(parseInt(NaN));//nan
            // console.log(parseInt(''));//NaN
            // console.log(parseInt('22.5'));//22
            // console.log(parseInt('0xf'));//15
            // ECMAscript3跟ECMAscript5在转换八进制的数字字符会出现不同，3是将当成八进制，而5会当成十进制。


            // 2019.2.21
            // class对象--特殊的函数
            // 函数有提升，但是类没有，在类申明之前使用类，会报错；
            // 类有两种表达式，一种是匿名类，一种是命名类
            // 匿名类
            // let Circle=class {
            //     constructor(point,r){
            //         this.point=point;
            //         this.r=r;
            //     }
            // }
            // // 命名的类
            // let Rectangle=class Rectangle{
            //     constructor(height,width){
            //         this.height=height;
            //         this.width=width;
            //     }
            // }
            // 一个构造函数可以使用super关键字来调用一个父类的构造函数
            // 静态方法
            // static关键字用来定义一个静态方法，与C#一样，不能通过类实例调用静态方法。调用静态方法不需要实例化该类。
            // 静态方法通常用于为一个应用程序创建工具函数

            // class Point{
            //     constructor(x,y){
            //         this.x=x;
            //         this.y=y;
            //     }
            //     static distance(a,b){
            //         const dx=a.x-b.x;
            //         const dy=a.y-b.y;
            //         return Math.hypot(dx,dy);
            //     }
            // }
            // const p1=new Point(5,5);
            // const p2=new Point(10,10);
            // 调用静态方法
            // console.log(Point.distance(p1,p2));

            // 用原型和静态方法包装

            /**
            当一个对象调用静态或原型方法时，如果该对象没有“this”值（或“this”作为布尔，字符串，数字，未定义或null) ，
            那么“this”值在被调用的函数内部将为 undefined。不会发生自动包装。即使我们以非严格模式编写代码，
            它的行为也是一样的，因为所有的函数、方法、构造函数、getters或setters都在严格模式下执行。
            因此如果我们没有指定this的值，this值将为undefined。
            */
            // class Animal{
            //     speak(){
            //         return this;
            //     }
            //     static eat(){
            //         return this;
            //     }
            // }
            // let obj=new Animal();
            // console.log(obj.speak());//Animal {}
            // let speak=obj.speak;
            // console.log(speak());//undefined
            // Animal.eat();
            // let eat=Animal.eat;
            // console.log(eat());//undefined
            // 如果使用传统的基于函数的类来编写上述代码，那么基于调用该函数的“this”值将发生自动装箱。
            // function Animal() {}
            // Animal.prototype.speak = function () {
            // return this;
            // }
            // Animal.eat = function () {
            // return this;
            // }
            // let obj=new Animal();
            // let speak=obj.speak;
            // console.log(speak());//Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}
            // let eat=Animal.eat;
            // console.log(eat());//Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}


            // 类的继承
            // class Animal{
            //     constructor(name){
            //         this.name=name;
            //     }
            //     speak(){
            //         console.log(this.name+' makes a noise');
            //     }
            // }

            // class Dog extends Animal{
            //     speak(){
            //         console.log(this.name+' barks.');
            //     }
            // }
            // let d=new Dog('xxxx');
            // d.speak();//xxxx barks.
            // 如果子类中存在构造函数，则需要在使用this之前首先调用super();

            // class Animal{
            //     constructor(name){
            //         this.name=name;
            //     }
            //     speak(){
            //         console.log(this.name+' makes a noise');
            //     }
            // }

            // class Dog extends Animal{
            //     constructor(name,age){
            //         super(name);
            //         this.age=age;
            //     }
            //     speak(){
            //         console.log(this.name+' barks.');
            //     }
            //     speakAge(){
            //         console.log(this.age+' hhhhs')
            //     }
            // }
            // let d=new Dog('xxxx',28);
            // d.speak();//xxxx barks.
            // d.speakAge();


            // 扩展传统的基于函数的类
            // function Animal(name){
            //     this.name=name;
            // }
            // Animal.prototype.speak=function(){
            //     console.log(this.name+' makes a moise');
            // }
            // class Dog extends Animal{
            //     speak(){
            //         super.speak();
            //         console.log(this.name+' barks.');
            //     }
            // }
            // var d=new Dog('cccc');
            // d.speak();

            // 请注意，类不能继承常规（非可构造）对象。如果要继承常规对象，可以改用Object.setPrototypeOf()：


            // var Animal={
            //     speak(){
            //         console.log(this.name+' makes a noise.');
            //     }
            // };
            // class Dog{
            //     constructor(name) {
            //         this.name=name;
            //     }
            // }
            // // 给Dog.prototype设置新的原型，Aniaml
            // Object.setPrototypeOf(Dog.prototype,Animal);
            // var d=new Dog(' vvvv');
            // d.speak();//vvvv makes a noise.

            // 派生数组类 MyArray 中返回 Array对象。这种 species 方式允许你覆盖默认的构造函数
            // class MyArray extends Array {
            //     static get[Symbol.species]() {
            //         return Array;
            //     }
            // }
            // var a = new MyArray(1, 2, 3);
            // var mapped = a.map(x => x * x);
            // console.log(mapped instanceof MyArray); //false
            // console.log(mapped instanceof Array); //true

            // super()  关键字用于调用对象的父对象上的函数。
            class Cat {
                constructor(name) {
                    this.name = name;
                }

                speak() {
                    console.log(this.name + ' makes a noise.');
                }
            }

            class Lion extends Cat {
                speak() {
                    super.speak();
                    console.log(this.name + ' roars.');
                }
            }
        </script>
    </div>
</body>

</html>